<comment> ::== ;[.^\n]*\n //FIXME
<numeral> ::== 0 | [1-9][0-9]*
<decimal> ::== <numeral>.0*<numeral>
<hexadecimal> ::== #x[0-9A-F]+
<binary> ::== #b[0-1]+
<string> ::== "" //FIXME
<symbol> ::== [a-zA-Z~!@$%^&*_-+=<>.?/][a-zA-Z0-9~!@$%^&*_-+=<>.?/]* | \|[.^|]*\| //FIXME
<keyword> ::== :[a-zA-Z0-9~!@$%^&*_-+=<>.?/]+
                            
<spec_constant> ::= <numeral> | <decimal> | <hexadecimal> | <binary> | <string>
<s_expr> ::= <spec_constant> | <symbol> | <keyword> | ( <s_expr>* )

<identifier> ::== <symbol> | ( _<symbol> <numeral>+ )   
<attribute_value> ::= <spec_constant>| <symbol> | ( s_expr* )
<attribute> ::= <keyword> | <keyword> <attribute_value>

<sort> ::= <identifier> | ( <identifier> <sort>+ )

// Formulas
<qual_identifier> ::= <identifier> | ( as <identifier> <sort> )
<var_binding> ::= ( <symbol> <term> )
<sorted_var> ::= ( <symbol> <sort> )
<term> ::== <spec constant>
		| <qual_identifier>
		| ( <qual_identifier> <term>+ )
		| ( let ( <var_binding>+ ) <term> )
		| ( forall ( <sorted_var>+ ) <term> )
		| ( exists ( <sorted_var>+ ) <term> )
		| ( ! <term> <attribute>+ )
		
		
// Theory declarations
<sort_symbol_decl> ::= ( <identifier> <numeral> <attribute>* )
<meta_spec_constant> ::= NUMERAL | DECIMAL | STRING
<fun_symbol_decl> ::== ( <spec_constant> <sort> <attribute>* )
		| ( <meta_spec_constant> <sort> <attribute>* )
		| ( <identifier> <sort>+ <attribute>* )
<par_fun_symbol_decl> ::== <fun_symbol_decl>
		| ( par ( <symbol>+ ) ( <identifier> <sort>+ <attribute>* ) )
<theory_attribute> ::== :sort ( <sort_symbol>+ ) // <sort_symbol> is not defined. Maybe they meant <sort> or <sort_symbol_decl>
		| :funs ( <par_fun_symbol_decl>+ )
		| :sorts-description <string>
		| :funs-description <string>
		| :definition <string>
		| :values <string>
		| :notes <string>
		| <attribute>
<theory_decl> ::== ( theory <symbol> <theory_attribute>+ )


// Logic declarations
<logic_attribute> ::== :theories ( <symbol>+ )
		| :language <string>
		| :extensions <string>
		| :values <string>
		| :notes <string>
		| <attribute>
<logic> ::== ( logic <symbol> <logic_attribute>+ )


// Scripts
<command> ::== ( set-logic <symbol> ) // The logic could be set multiple times in any place the script
		| ( set-option <option> )
		| ( set-info <attribute> )
		| ( declare-sort <symbol> <numeral> )
		| ( define-sort <symbol> ( <symbol>* ) <sort> )
		| ( declare-fun <symbol> ( <sort>* ) <sort> )
		| ( define-fun <symbol> ( <sorted_var>* ) <sort> <term> )
		| ( push <numeral> )
		| ( pop <numeral> )
		| ( assert <term> )
		| ( check-sat )
		| ( get-assertions )
		| ( get-proof )
		| ( get-unsat-core )
		| ( get-value ( <term>+ ) )
		| ( get-assignment )
		| ( get-option <keyword> )
		| ( get-info <info_flag> )
		| ( exit ) // Comments are missing??
<script> ::== <command>*

<b_value> ::== true | false // this does not match with <spec_constant>
<option> ::== :print-success <b_value>
		| :expand-definitions <b_value>
		| :interactive.mode <b_value>
		| :produce-proofs <b_value>
		| :produce-unsat.cores <b_value>
		| :produce-models <b_value>
		| :produce-assignments <b_value>
		| :regular-output-channel <string>
		| :diagnostic-output-channel <string>
		| :random-seed <numeral>
		| :verbosity <numeral>
		| <attribute>


<info_flag> ::= :error-behavior
           | :name
           | :authors
           | :version
           | :status
           | :reason-unknown
           | <keyword>
           | :all-statistics
           
                 
<gen_response> ::= unsupported | success | ( error <string> )
<error-behavior> ::== immediate-exit | continued-execution
<reason-unknown> ::== memout | incomplete
<status> ::== sat | unsat | unknown
<info_response> ::== :error-behavior <error-behavior>
		| :name <string>
		| :authors <string>
		| :version <string>
		| :reason-unknown <reason-unknown>
		| <attribute>
<get_info_response> ::== ( <info_response>+ )
<check_sat_response> ::== <status>
<get_assertion_response> ::== ( <term>* )
<proof> ::== <s_expr>
<get_proof_response> ::== <proof>
<get_unsat_core_response ::== ( <symbol>* )
<valuation_pair> ::== ( <term> <term> )
<get_value_response> ::== ( <valuation_pair>+ )
<t_valuation_pair> ::== ( <symbol> <b_value>) // Why <b_value> and not <spec_constant> or <attribute_value>
<get_assignment_response> ::== ( <t_valuation_pair>* )
<get_option_response> ::== <attribute_value>
